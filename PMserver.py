from os import path
import time
import threading
import BluetoothChannel
from AutoStore import Product as Database

# Class for coordinating and controlling PickMaster robots.
class RobotServer:
    robot_names = ["Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Zeta", "Eta", "Theta"]
    active_robots = 0
    log_jobs = True
    print_log_entries = True
    job_list = []
    active_jobs = []
    next_job_ID = 0

    # Single server object responsible for all printing to prevent race conditions.
    def print(self, text):
        print(text)

    # Writes input text to log file with time stamp.
    def write_log(self, text):
        log_entry = time.asctime() + ":  " + text
        if self.print_log_entries:
            print("logged:", log_entry)
        log = open(self.log_path, "a")
        log.write(log_entry + "\n")
        log.close()

    # Constructor with optional log file-path parameter. Creates new log file if none is found.
    def __init__(self, log_path="log.txt"):
        self.log_path = log_path
        if not path.exists(log_path):
            log = open(log_path, "w")
            log.write("This is the log file generated by the Pick Master server\n\n")
            log.close()
        self.write_log("==========server initiated==========")

    # Destructor. For cleaning up while shutting down. Does currently not actually clean up.
    def __del__(self):
        self.write_log("server shut down")

    # Add input text to job que with job unique ID in format "ID-job"
    def add_job(self, text):
        self.job_list.append(str(self.next_job_ID) + "-" + text)
        if self.log_jobs:
            self.write_log("job added: " + self.job_list[-1])
        self.next_job_ID += 1

    # Removes job from que if a job in que matches input job ID.
    def cancel_job(self, job_ID):
        for n in range(len(self.job_list)):
            if self.job_list[n].split("-")[0] == job_ID:
                if self.log_jobs:
                    self.write_log("canceling job: " + self.job_list[n])
                self.job_list.remove(n)
                return
        self.write_log("cannot cancel: " + job_ID + ", job not found")

    # Returns first job in que, removing it from the que. Returns "noJob" if que is empty.
    def send_job(self, robot_name):
        if len(self.job_list) > 0:
            work = self.job_list[0] + "-" + robot_name
            self.active_jobs.append(work)
            if self.log_jobs:
                self.write_log("job: " + self.job_list[0] + " sent to robot: " + robot_name)
            return self.job_list.pop(0)
        else:
            return "noJob"

    # Returns an unused name from name-list. Giving robots human readable names should make log entries more readable
    # and bug hunting much easier. Most significant if the system handles multiple robots.
    def send_name(self):
        if len(self.robot_names) > self.active_robots:
            name = self.robot_names[self.active_robots]
        else:
            name = str(self.active_robots)
        self.active_robots += 1
        return name

    # Handles robot losing connection. Does very little at the moment.
    def lost_robot_connection(self, robot_name):
        self.write_log("robot " + robot_name + ": lost connection")
        self.active_robots -= 1

    # Do something if robot does not connect. Currently only writes to log.
    def no_robot_connection(self, robot_name):
        self.write_log("robot " + robot_name + ": no connection")
        return

    # Returns a brief status report as a string. Reports number of currently active robots and current job que.
    def status(self):
        output = "Connected robots: " + str(self.active_robots) + "\n"
        print("Job que:")
        for job in self.job_list:
            output += "    " + job + "\n"
        return output


# Initialize server-system with one robot.
if __name__ == "__main__":
    robot_server = RobotServer()
    database = Database()
    channel = BluetoothChannel.RobotChannel("pickmaster2/main.py", robot_server)
    # Spin off robot bluetooth communication channel as separate thread, so that a single robot cannot block the server.
    robot_com_thread = threading.Thread(target=channel.run)
    robot_com_thread.start()
    # Add some test products to database.
    database.allProducts.update({"nothing": {"X_count": 1, "Y_count": 2}})
    database.allProducts.update({"luft": {"X_count": 2, "Y_count": 0}})

    # main user interface loop.
    while True:
        print("\n<d> access database, <j> create job directly, <s> status, <x> shutdown server")
        userin = input()
        if userin == "d":
            try:
                coordinates = database.run()
                if coordinates is not None:
                    job = str(coordinates[0]) + "," + str(coordinates[1])
                    robot_server.add_job(job)
            except ValueError:
                print("! error !")
        elif userin == "s":
            print(robot_server.status())
        elif userin == "j":
            job = input("write new job\n")
            robot_server.add_job(job)
        elif userin == "x":
            robot_server.add_job("EXIT")
            print("Shutting down robots")
            break
    robot_com_thread.join()
    del robot_server
